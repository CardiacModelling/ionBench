#This algorithm is a minor modification to the one presented in Press "Numerical Recipes in C". It uses a Nelder Mead simplex search but with simulated annealing style acceptance probabilities
#This code was first implemented as a standard nelder mead, tested against scipy nelder mead, where it matched (once the same initialization procedure for the simplex was used), then adjusted to reproduce the simulated annealing of "Numerical Recipes in C"

import numpy as np
import ionbench

def run(bm, x0 = [], maxIter = 10, debug=False):
    """

    Parameters
    ----------
    bm : Benchmarker
        A benchmarker to evaluate the performance of the optimisation algorithm.
    x0 : list, optional
        Initial parameter guess. Population is generated by randomly perturbing this initial guess +-50%, then applying the appropriate bounds. If x0=[] (the default), then the population will be sampled uniformly between the bounds.
    debug : bool, optional
        If True, debug information will be printed, reporting that status of the optimisation each generation. The default is False.

    Returns
    -------
    xbest : list
        The best parameters identified.

    """
    #class for points on the simplex
    class Point:
        def __init__(self, x):
            self.x = x
            self.cost = bm.cost(x)
    
    #class for the simplex
    class Simplex:
        def __init__(self, points):
            self.points = points
        def get_best(self):
            #returns the best point in the simplex
            x_best = self.points[0]
            for p in self.points:
                if p.cost < x_best.cost:
                    x_best = p
            return x_best
        def get_worst(self):
            #returns the worst point in the simplex
            x_worst = self.points[0]
            for p in self.points:
                if p.cost > x_worst.cost:
                    x_worst = p
            return x_worst
        def get_second_worst(self):
            #returns second worst
            x_worst = self.get_worst()
            x_secondWorst = self.points[0]
            for p in self.points:
                if p.cost > x_secondWorst.cost and p != x_worst:
                    x_secondWorst = p
            return x_secondWorst
        def centroid(self, x_worst):
            #find the centroid of the simplex by averaging the x positions, not including x_worst. Dont generate a point, cost not needed
            posSum = [0]*bm.n_parameters()
            for p in self.points:
                if p != x_worst:
                    posSum += p.x
            posSum /= len(self.points)-1
            return posSum
        def accept(self, x):
            x_worst = self.get_worst()
            for i in range(len(self.points)):
                if self.points[i] == x_worst:
                    self.points[i] = x
                    return
        def step(self):
            """
            The original Nelder-Mead paper uses “greedy expansion”, where xe is accepted if fe<fl and fr<fl , regardless of the relationship between fr and fe . It may happen that fr<fe , so xr would be a better new point than xe , and xe is still accepted for the new simplex. http://www.scholarpedia.org/article/Nelder-Mead_algorithm
            """
            x_worst = self.get_worst()
            x_best = self.get_best()
            x_secondWorst = self.get_second_worst()
            c = self.centroid(x_worst)
            #attempt reflection
            xr = Point(2*c-x_worst.x)
            if xr.cost < x_secondWorst.cost and xr.cost >= x_best.cost:
                if debug:
                    print("Accept reflection")
                self.accept(xr)
                return
            if xr.cost < x_best.cost:
                #Attempt expand
                xe = Point(2*xr.x-c)
                if xe.cost < xr.cost:
                    if debug:
                        print("Accept expansion")
                    self.accept(xe)
                else:
                    if debug:
                        print("Ignore expansion. Accept reflection")
                    self.accept(xr)
                return
            if xr.cost >= x_secondWorst.cost:
                #contract
                if debug:
                    print("Attempt contraction")
                if xr.cost < x_worst.cost and xr.cost >= x_secondWorst.cost:
                    #outside contract
                    xc = Point((xr.x+c)/2)
                    if xc.cost <= xr.cost:
                        if debug:
                            print("Accept inside contraction")
                        self.accept(xc)
                        return
                else:
                    #inside contract
                    xc = Point((x_worst.x+c)/2)
                    if xc.cost < x_worst.cost:
                        if debug:
                            print("Accept inside contraction")
                        self.accept(xc)
                        return
            #shrink
            if debug:
                print("Shrink")
            for i in range(len(self.points)):
                if self.points[i] != x_best:
                    self.points[i] = Point((x_best.x+self.points[i].x)/2)
            return
    
    if len(x0)==0:
        #sample initial point
        x0 = bm.sample()
    
    points = [Point(x0)]
    perturbVector = 0.05*x0
    for i in range(bm.n_parameters()):
        perturb = np.zeros(bm.n_parameters())
        perturb[i] = perturbVector[i]
        points.append(Point(x0+perturb))
    
    simplex = Simplex(points)
    for i in range(maxIter):
        simplex.step()
    
    x_best = simplex.get_best().x
    bm.evaluate(x_best)
    return x_best

if __name__ == '__main__':
    bm = ionbench.problems.loewe2016.ikr()
    x0 = bm.sample()
    print(bm.cost(x0))
    x = run(bm,x0=x0, maxIter = 1000, debug=True)
    print(bm.cost(x))

def get_modification():
    """

    Returns
    -------
    mod : modification
        The modification used in 

    """
    mod = ionbench.modification.Vanier1999()
    return mod
